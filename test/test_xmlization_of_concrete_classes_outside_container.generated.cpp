// This code has been automatically generated by:
// dev_scripts/test_codegen/generate_test_xmlization_of_concrete_classes_outside_container.py
// Do NOT edit or append.

#include "./common_examples.generated.hpp"

#include <aas_core/aas_3_0/xmlization.hpp>

#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>

namespace aas = aas_core::aas_3_0;

TEST_CASE("Test the round-trip of an expected IExtension") {
  const std::shared_ptr<
    aas::types::IExtension
  > original_instance(
    test::common::examples::LoadMinExtension()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IExtension: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IExtension "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IAdministrativeInformation") {
  const std::shared_ptr<
    aas::types::IAdministrativeInformation
  > original_instance(
    test::common::examples::LoadMinAdministrativeInformation()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IAdministrativeInformation: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IAdministrativeInformation "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IQualifier") {
  const std::shared_ptr<
    aas::types::IQualifier
  > original_instance(
    test::common::examples::LoadMinQualifier()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IQualifier: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IQualifier "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IAssetAdministrationShell") {
  const std::shared_ptr<
    aas::types::IAssetAdministrationShell
  > original_instance(
    test::common::examples::LoadMinAssetAdministrationShell()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IAssetAdministrationShell: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IAssetAdministrationShell "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IAssetInformation") {
  const std::shared_ptr<
    aas::types::IAssetInformation
  > original_instance(
    test::common::examples::LoadMinAssetInformation()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IAssetInformation: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IAssetInformation "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IResource") {
  const std::shared_ptr<
    aas::types::IResource
  > original_instance(
    test::common::examples::LoadMinResource()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IResource: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IResource "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ISpecificAssetId") {
  const std::shared_ptr<
    aas::types::ISpecificAssetId
  > original_instance(
    test::common::examples::LoadMinSpecificAssetId()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ISpecificAssetId: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ISpecificAssetId "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ISubmodel") {
  const std::shared_ptr<
    aas::types::ISubmodel
  > original_instance(
    test::common::examples::LoadMinSubmodel()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ISubmodel: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ISubmodel "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IRelationshipElement") {
  const std::shared_ptr<
    aas::types::IRelationshipElement
  > original_instance(
    test::common::examples::LoadMinRelationshipElement()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IRelationshipElement: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IRelationshipElement "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ISubmodelElementList") {
  const std::shared_ptr<
    aas::types::ISubmodelElementList
  > original_instance(
    test::common::examples::LoadMinSubmodelElementList()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ISubmodelElementList: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ISubmodelElementList "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ISubmodelElementCollection") {
  const std::shared_ptr<
    aas::types::ISubmodelElementCollection
  > original_instance(
    test::common::examples::LoadMinSubmodelElementCollection()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ISubmodelElementCollection: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ISubmodelElementCollection "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IProperty") {
  const std::shared_ptr<
    aas::types::IProperty
  > original_instance(
    test::common::examples::LoadMinProperty()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IProperty: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IProperty "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IMultiLanguageProperty") {
  const std::shared_ptr<
    aas::types::IMultiLanguageProperty
  > original_instance(
    test::common::examples::LoadMinMultiLanguageProperty()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IMultiLanguageProperty: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IMultiLanguageProperty "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IRange") {
  const std::shared_ptr<
    aas::types::IRange
  > original_instance(
    test::common::examples::LoadMinRange()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IRange: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IRange "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IReferenceElement") {
  const std::shared_ptr<
    aas::types::IReferenceElement
  > original_instance(
    test::common::examples::LoadMinReferenceElement()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IReferenceElement: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IReferenceElement "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IBlob") {
  const std::shared_ptr<
    aas::types::IBlob
  > original_instance(
    test::common::examples::LoadMinBlob()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IBlob: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IBlob "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IFile") {
  const std::shared_ptr<
    aas::types::IFile
  > original_instance(
    test::common::examples::LoadMinFile()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IFile: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IFile "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IAnnotatedRelationshipElement") {
  const std::shared_ptr<
    aas::types::IAnnotatedRelationshipElement
  > original_instance(
    test::common::examples::LoadMinAnnotatedRelationshipElement()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IAnnotatedRelationshipElement: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IAnnotatedRelationshipElement "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IEntity") {
  const std::shared_ptr<
    aas::types::IEntity
  > original_instance(
    test::common::examples::LoadMinEntity()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IEntity: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IEntity "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IBasicEventElement") {
  const std::shared_ptr<
    aas::types::IBasicEventElement
  > original_instance(
    test::common::examples::LoadMinBasicEventElement()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IBasicEventElement: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IBasicEventElement "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IOperation") {
  const std::shared_ptr<
    aas::types::IOperation
  > original_instance(
    test::common::examples::LoadMinOperation()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IOperation: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IOperation "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IOperationVariable") {
  const std::shared_ptr<
    aas::types::IOperationVariable
  > original_instance(
    test::common::examples::LoadMinOperationVariable()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IOperationVariable: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IOperationVariable "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ICapability") {
  const std::shared_ptr<
    aas::types::ICapability
  > original_instance(
    test::common::examples::LoadMinCapability()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ICapability: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ICapability "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IConceptDescription") {
  const std::shared_ptr<
    aas::types::IConceptDescription
  > original_instance(
    test::common::examples::LoadMinConceptDescription()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IConceptDescription: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IConceptDescription "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IReference") {
  const std::shared_ptr<
    aas::types::IReference
  > original_instance(
    test::common::examples::LoadMinReference()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IReference: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IReference "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IKey") {
  const std::shared_ptr<
    aas::types::IKey
  > original_instance(
    test::common::examples::LoadMinKey()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IKey: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IKey "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ILangStringNameType") {
  const std::shared_ptr<
    aas::types::ILangStringNameType
  > original_instance(
    test::common::examples::LoadMinLangStringNameType()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ILangStringNameType: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ILangStringNameType "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ILangStringTextType") {
  const std::shared_ptr<
    aas::types::ILangStringTextType
  > original_instance(
    test::common::examples::LoadMinLangStringTextType()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ILangStringTextType: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ILangStringTextType "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IEmbeddedDataSpecification") {
  const std::shared_ptr<
    aas::types::IEmbeddedDataSpecification
  > original_instance(
    test::common::examples::LoadMinEmbeddedDataSpecification()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IEmbeddedDataSpecification: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IEmbeddedDataSpecification "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ILevelType") {
  const std::shared_ptr<
    aas::types::ILevelType
  > original_instance(
    test::common::examples::LoadMinLevelType()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ILevelType: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ILevelType "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IValueReferencePair") {
  const std::shared_ptr<
    aas::types::IValueReferencePair
  > original_instance(
    test::common::examples::LoadMinValueReferencePair()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IValueReferencePair: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IValueReferencePair "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IValueList") {
  const std::shared_ptr<
    aas::types::IValueList
  > original_instance(
    test::common::examples::LoadMinValueList()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IValueList: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IValueList "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ILangStringPreferredNameTypeIec61360") {
  const std::shared_ptr<
    aas::types::ILangStringPreferredNameTypeIec61360
  > original_instance(
    test::common::examples::LoadMinLangStringPreferredNameTypeIec61360()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ILangStringPreferredNameTypeIec61360: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ILangStringPreferredNameTypeIec61360 "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ILangStringShortNameTypeIec61360") {
  const std::shared_ptr<
    aas::types::ILangStringShortNameTypeIec61360
  > original_instance(
    test::common::examples::LoadMinLangStringShortNameTypeIec61360()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ILangStringShortNameTypeIec61360: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ILangStringShortNameTypeIec61360 "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected ILangStringDefinitionTypeIec61360") {
  const std::shared_ptr<
    aas::types::ILangStringDefinitionTypeIec61360
  > original_instance(
    test::common::examples::LoadMinLangStringDefinitionTypeIec61360()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of ILangStringDefinitionTypeIec61360: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of ILangStringDefinitionTypeIec61360 "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

TEST_CASE("Test the round-trip of an expected IDataSpecificationIec61360") {
  const std::shared_ptr<
    aas::types::IDataSpecificationIec61360
  > original_instance(
    test::common::examples::LoadMinDataSpecificationIec61360()
  );

  std::stringstream ss;
  aas::xmlization::Serialize(
    *original_instance,
    {},
    ss
  );

  const std::string original_xml = ss.str();

  ss.seekp(0);

  aas::common::expected<
    std::shared_ptr<aas::types::IClass>,
    aas::xmlization::DeserializationError
  > deserialized = aas::xmlization::From(
    ss
  );

  if (!deserialized.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make the round-trip Serialize-Deserialize "
        "a minimal instance of IDataSpecificationIec61360: ",
        aas::common::WstringToUtf8(
          deserialized.error().path.ToWstring()
        ),
        ": ",
        aas::common::WstringToUtf8(
          deserialized.error().cause
        )
      )
    )
    REQUIRE(deserialized.has_value());
  }

  std::stringstream another_ss;
  aas::xmlization::Serialize(
    *deserialized.value(),
    {},
    another_ss
  );

  INFO(
    "Original XML and the XML at the end of "
    "the chain Serialize-Deserialize-Serialize for "
    "a minimal instance of IDataSpecificationIec61360 "
    "must coincide"
  )
  REQUIRE(
    original_xml
    == another_ss.str()
  );
}

// This code has been automatically generated by:
// dev_scripts/test_codegen/generate_test_xmlization_of_concrete_classes_outside_container.py
// Do NOT edit or append.
