// This code has been automatically generated by:
// dev_scripts/test_codegen/generate_test_jsonization_dispatch.py
// Do NOT edit or append.

#include "./common.hpp"
#include "./common_jsonization.hpp"
#include "./common_examples.generated.hpp"

#include <aas_core/aas_3_0/jsonization.hpp>

#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>

namespace aas = aas_core::aas_3_0;

TEST_CASE("Test the round-trip of an expected IReferable") {
  const std::shared_ptr<
    aas::types::IRelationshipElement
  > concrete_instance(
    test::common::examples::LoadMinRelationshipElement()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *concrete_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IReferable
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::ReferableFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IReferable "
        "from a minimal IRelationshipElement: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IReferable "
        "over a minimal IRelationshipElement: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IIdentifiable") {
  const std::shared_ptr<
    aas::types::IAssetAdministrationShell
  > concrete_instance(
    test::common::examples::LoadMinAssetAdministrationShell()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *concrete_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IIdentifiable
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::IdentifiableFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IIdentifiable "
        "from a minimal IAssetAdministrationShell: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IIdentifiable "
        "over a minimal IAssetAdministrationShell: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IQualifiable") {
  const std::shared_ptr<
    aas::types::IRelationshipElement
  > concrete_instance(
    test::common::examples::LoadMinRelationshipElement()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *concrete_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IQualifiable
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::QualifiableFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IQualifiable "
        "from a minimal IRelationshipElement: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IQualifiable "
        "over a minimal IRelationshipElement: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ISubmodelElement") {
  const std::shared_ptr<
    aas::types::IRelationshipElement
  > concrete_instance(
    test::common::examples::LoadMinRelationshipElement()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *concrete_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ISubmodelElement
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::SubmodelElementFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ISubmodelElement "
        "from a minimal IRelationshipElement: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ISubmodelElement "
        "over a minimal IRelationshipElement: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IRelationshipElement") {
  const std::shared_ptr<
    aas::types::IAnnotatedRelationshipElement
  > concrete_instance(
    test::common::examples::LoadMinAnnotatedRelationshipElement()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *concrete_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IRelationshipElement
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::RelationshipElementFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IRelationshipElement "
        "from a minimal IAnnotatedRelationshipElement: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IRelationshipElement "
        "over a minimal IAnnotatedRelationshipElement: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IDataElement") {
  const std::shared_ptr<
    aas::types::IBlob
  > concrete_instance(
    test::common::examples::LoadMinBlob()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *concrete_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IDataElement
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::DataElementFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IDataElement "
        "from a minimal IBlob: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IDataElement "
        "over a minimal IBlob: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IEventElement") {
  const std::shared_ptr<
    aas::types::IBasicEventElement
  > concrete_instance(
    test::common::examples::LoadMinBasicEventElement()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *concrete_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IEventElement
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::EventElementFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IEventElement "
        "from a minimal IBasicEventElement: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IEventElement "
        "over a minimal IBasicEventElement: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IDataSpecificationContent") {
  const std::shared_ptr<
    aas::types::IDataSpecificationIec61360
  > concrete_instance(
    test::common::examples::LoadMinDataSpecificationIec61360()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *concrete_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IDataSpecificationContent
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::DataSpecificationContentFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IDataSpecificationContent "
        "from a minimal IDataSpecificationIec61360: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IDataSpecificationContent "
        "over a minimal IDataSpecificationIec61360: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

// This code has been automatically generated by:
// dev_scripts/test_codegen/generate_test_jsonization_dispatch.py
// Do NOT edit or append.
