// This code has been automatically generated by:
// dev_scripts/test_codegen/generate_test_jsonization_of_concrete_classes_outside_container.py
// Do NOT edit or append.

#include "./common.hpp"
#include "./common_jsonization.hpp"
#include "./common_examples.generated.hpp"

#include <aas_core/aas_3_0/jsonization.hpp>

#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>

namespace aas = aas_core::aas_3_0;

TEST_CASE("Test the round-trip of an expected IExtension") {
  const std::shared_ptr<
    aas::types::IExtension
  > original_instance(
    test::common::examples::LoadMinExtension()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IExtension
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::ExtensionFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IExtension "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IExtension "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IAdministrativeInformation") {
  const std::shared_ptr<
    aas::types::IAdministrativeInformation
  > original_instance(
    test::common::examples::LoadMinAdministrativeInformation()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IAdministrativeInformation
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::AdministrativeInformationFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IAdministrativeInformation "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IAdministrativeInformation "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IQualifier") {
  const std::shared_ptr<
    aas::types::IQualifier
  > original_instance(
    test::common::examples::LoadMinQualifier()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IQualifier
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::QualifierFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IQualifier "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IQualifier "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IAssetAdministrationShell") {
  const std::shared_ptr<
    aas::types::IAssetAdministrationShell
  > original_instance(
    test::common::examples::LoadMinAssetAdministrationShell()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IAssetAdministrationShell
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::AssetAdministrationShellFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IAssetAdministrationShell "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IAssetAdministrationShell "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IAssetInformation") {
  const std::shared_ptr<
    aas::types::IAssetInformation
  > original_instance(
    test::common::examples::LoadMinAssetInformation()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IAssetInformation
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::AssetInformationFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IAssetInformation "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IAssetInformation "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IResource") {
  const std::shared_ptr<
    aas::types::IResource
  > original_instance(
    test::common::examples::LoadMinResource()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IResource
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::ResourceFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IResource "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IResource "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ISpecificAssetId") {
  const std::shared_ptr<
    aas::types::ISpecificAssetId
  > original_instance(
    test::common::examples::LoadMinSpecificAssetId()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ISpecificAssetId
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::SpecificAssetIdFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ISpecificAssetId "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ISpecificAssetId "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ISubmodel") {
  const std::shared_ptr<
    aas::types::ISubmodel
  > original_instance(
    test::common::examples::LoadMinSubmodel()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ISubmodel
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::SubmodelFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ISubmodel "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ISubmodel "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IRelationshipElement") {
  const std::shared_ptr<
    aas::types::IRelationshipElement
  > original_instance(
    test::common::examples::LoadMinRelationshipElement()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IRelationshipElement
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::RelationshipElementFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IRelationshipElement "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IRelationshipElement "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ISubmodelElementList") {
  const std::shared_ptr<
    aas::types::ISubmodelElementList
  > original_instance(
    test::common::examples::LoadMinSubmodelElementList()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ISubmodelElementList
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::SubmodelElementListFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ISubmodelElementList "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ISubmodelElementList "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ISubmodelElementCollection") {
  const std::shared_ptr<
    aas::types::ISubmodelElementCollection
  > original_instance(
    test::common::examples::LoadMinSubmodelElementCollection()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ISubmodelElementCollection
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::SubmodelElementCollectionFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ISubmodelElementCollection "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ISubmodelElementCollection "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IProperty") {
  const std::shared_ptr<
    aas::types::IProperty
  > original_instance(
    test::common::examples::LoadMinProperty()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IProperty
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::PropertyFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IProperty "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IProperty "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IMultiLanguageProperty") {
  const std::shared_ptr<
    aas::types::IMultiLanguageProperty
  > original_instance(
    test::common::examples::LoadMinMultiLanguageProperty()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IMultiLanguageProperty
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::MultiLanguagePropertyFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IMultiLanguageProperty "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IMultiLanguageProperty "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IRange") {
  const std::shared_ptr<
    aas::types::IRange
  > original_instance(
    test::common::examples::LoadMinRange()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IRange
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::RangeFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IRange "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IRange "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IReferenceElement") {
  const std::shared_ptr<
    aas::types::IReferenceElement
  > original_instance(
    test::common::examples::LoadMinReferenceElement()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IReferenceElement
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::ReferenceElementFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IReferenceElement "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IReferenceElement "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IBlob") {
  const std::shared_ptr<
    aas::types::IBlob
  > original_instance(
    test::common::examples::LoadMinBlob()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IBlob
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::BlobFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IBlob "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IBlob "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IFile") {
  const std::shared_ptr<
    aas::types::IFile
  > original_instance(
    test::common::examples::LoadMinFile()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IFile
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::FileFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IFile "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IFile "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IAnnotatedRelationshipElement") {
  const std::shared_ptr<
    aas::types::IAnnotatedRelationshipElement
  > original_instance(
    test::common::examples::LoadMinAnnotatedRelationshipElement()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IAnnotatedRelationshipElement
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::AnnotatedRelationshipElementFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IAnnotatedRelationshipElement "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IAnnotatedRelationshipElement "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IEntity") {
  const std::shared_ptr<
    aas::types::IEntity
  > original_instance(
    test::common::examples::LoadMinEntity()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IEntity
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::EntityFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IEntity "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IEntity "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IBasicEventElement") {
  const std::shared_ptr<
    aas::types::IBasicEventElement
  > original_instance(
    test::common::examples::LoadMinBasicEventElement()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IBasicEventElement
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::BasicEventElementFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IBasicEventElement "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IBasicEventElement "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IOperation") {
  const std::shared_ptr<
    aas::types::IOperation
  > original_instance(
    test::common::examples::LoadMinOperation()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IOperation
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::OperationFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IOperation "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IOperation "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IOperationVariable") {
  const std::shared_ptr<
    aas::types::IOperationVariable
  > original_instance(
    test::common::examples::LoadMinOperationVariable()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IOperationVariable
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::OperationVariableFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IOperationVariable "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IOperationVariable "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ICapability") {
  const std::shared_ptr<
    aas::types::ICapability
  > original_instance(
    test::common::examples::LoadMinCapability()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ICapability
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::CapabilityFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ICapability "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ICapability "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IConceptDescription") {
  const std::shared_ptr<
    aas::types::IConceptDescription
  > original_instance(
    test::common::examples::LoadMinConceptDescription()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IConceptDescription
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::ConceptDescriptionFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IConceptDescription "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IConceptDescription "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IReference") {
  const std::shared_ptr<
    aas::types::IReference
  > original_instance(
    test::common::examples::LoadMinReference()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IReference
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::ReferenceFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IReference "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IReference "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IKey") {
  const std::shared_ptr<
    aas::types::IKey
  > original_instance(
    test::common::examples::LoadMinKey()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IKey
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::KeyFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IKey "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IKey "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ILangStringNameType") {
  const std::shared_ptr<
    aas::types::ILangStringNameType
  > original_instance(
    test::common::examples::LoadMinLangStringNameType()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ILangStringNameType
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::LangStringNameTypeFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ILangStringNameType "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ILangStringNameType "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ILangStringTextType") {
  const std::shared_ptr<
    aas::types::ILangStringTextType
  > original_instance(
    test::common::examples::LoadMinLangStringTextType()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ILangStringTextType
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::LangStringTextTypeFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ILangStringTextType "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ILangStringTextType "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IEmbeddedDataSpecification") {
  const std::shared_ptr<
    aas::types::IEmbeddedDataSpecification
  > original_instance(
    test::common::examples::LoadMinEmbeddedDataSpecification()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IEmbeddedDataSpecification
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::EmbeddedDataSpecificationFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IEmbeddedDataSpecification "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IEmbeddedDataSpecification "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ILevelType") {
  const std::shared_ptr<
    aas::types::ILevelType
  > original_instance(
    test::common::examples::LoadMinLevelType()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ILevelType
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::LevelTypeFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ILevelType "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ILevelType "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IValueReferencePair") {
  const std::shared_ptr<
    aas::types::IValueReferencePair
  > original_instance(
    test::common::examples::LoadMinValueReferencePair()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IValueReferencePair
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::ValueReferencePairFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IValueReferencePair "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IValueReferencePair "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IValueList") {
  const std::shared_ptr<
    aas::types::IValueList
  > original_instance(
    test::common::examples::LoadMinValueList()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IValueList
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::ValueListFrom(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IValueList "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IValueList "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ILangStringPreferredNameTypeIec61360") {
  const std::shared_ptr<
    aas::types::ILangStringPreferredNameTypeIec61360
  > original_instance(
    test::common::examples::LoadMinLangStringPreferredNameTypeIec61360()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ILangStringPreferredNameTypeIec61360
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::LangStringPreferredNameTypeIec61360From(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ILangStringPreferredNameTypeIec61360 "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ILangStringPreferredNameTypeIec61360 "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ILangStringShortNameTypeIec61360") {
  const std::shared_ptr<
    aas::types::ILangStringShortNameTypeIec61360
  > original_instance(
    test::common::examples::LoadMinLangStringShortNameTypeIec61360()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ILangStringShortNameTypeIec61360
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::LangStringShortNameTypeIec61360From(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ILangStringShortNameTypeIec61360 "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ILangStringShortNameTypeIec61360 "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected ILangStringDefinitionTypeIec61360") {
  const std::shared_ptr<
    aas::types::ILangStringDefinitionTypeIec61360
  > original_instance(
    test::common::examples::LoadMinLangStringDefinitionTypeIec61360()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::ILangStringDefinitionTypeIec61360
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::LangStringDefinitionTypeIec61360From(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a ILangStringDefinitionTypeIec61360 "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a ILangStringDefinitionTypeIec61360 "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

TEST_CASE("Test the round-trip of an expected IDataSpecificationIec61360") {
  const std::shared_ptr<
    aas::types::IDataSpecificationIec61360
  > original_instance(
    test::common::examples::LoadMinDataSpecificationIec61360()
  );

  const nlohmann::json json = aas::jsonization::Serialize(
    *original_instance
  );

  aas::common::expected<
    std::shared_ptr<
      aas::types::IDataSpecificationIec61360
    >,
    aas::jsonization::DeserializationError
  > instance = aas::jsonization::DataSpecificationIec61360From(
    json
  );

  if (!instance.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to deserialize a IDataSpecificationIec61360 "
        "from a minimal example: ",
        aas::common::WstringToUtf8(instance.error().path.ToWstring()),
        ": ",
        aas::common::WstringToUtf8(instance.error().cause)
      )
    )
    CHECK(instance.has_value());
  }

  const nlohmann::json another_json = aas::jsonization::Serialize(
    **instance
  );

  const std::optional<
    std::string
  > patch_message = test::common::jsonization::CompareJsons(
    json,
    another_json
  );
  if (patch_message.has_value()) {
    INFO(
      aas::common::Concat(
        "Failed to make a round-trip of a IDataSpecificationIec61360 "
        "over a minimal example: ",
        *patch_message
        )
      )
      CHECK(!patch_message.has_value());
  }
}

// This code has been automatically generated by:
// dev_scripts/test_codegen/generate_test_jsonization_of_concrete_classes_outside_container.py
// Do NOT edit or append.
